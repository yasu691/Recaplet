# 実装計画立案とステップ分割の標準化ルール

このドキュメントは、ソフトウェア開発プロジェクトにおいて、学習重視の段階的実装計画を立案するための標準化されたメソドロジーなのだ。

---

## 🎯 目的

1. **学習効果の最大化**: 実装者が理解しながら進められる計画
2. **動作確認の容易性**: 各ステップで独立して動作確認可能
3. **エラーの早期発見**: 小さい単位でテストするため、問題箇所を特定しやすい
4. **再現性**: 他のプロジェクトにも適用できる標準化された手法

---

## 📋 計画立案の全体フロー

```
1. 要件整理
   ↓
2. アーキテクチャ設計
   ↓
3. フェーズ分割（Phase 1〜N）
   ↓
4. ステップ分割（Step X-Y）
   ↓
5. 各ステップの詳細ドキュメント作成
   ↓
6. 実装開始
```

---

## Step 1: 要件整理

### 作業内容

ユーザーから提供された要件を以下の形式で整理する:

```markdown
## コア要件
- [ ] 機能要件1（例: RSS フィード設定可能）
- [ ] 機能要件2（例: 日本語要約の自動生成）
- [ ] 機能要件3（例: Android アプリ化）

## 非機能要件
- [ ] パフォーマンス（例: 30秒以内に処理完了）
- [ ] コスト（例: 月額 $5 以下）
- [ ] 可用性（例: 99% 稼働率）
```

### チェックポイント

- [ ] すべての要件が「測定可能」な形になっているか
- [ ] 優先度が明確か（必須 / 推奨 / オプション）
- [ ] ユーザーと認識が一致しているか

---

## Step 2: アーキテクチャ設計

### 作業内容

技術スタックと全体構成を決定する:

```markdown
## 技術スタック
- フロントエンド: [技術名]（理由: ...）
- バックエンド: [技術名]（理由: ...）
- データベース: [技術名]（理由: ...）
- ホスティング: [サービス名]（理由: ...）

## システム構成図
[ASCII アート or Mermaid で図示]

## コスト試算
- サービスA: $X/月
- サービスB: $Y/月
- 合計: $Z/月
```

### チェックポイント

- [ ] 技術選定の理由が明確か
- [ ] コスト見積もりは現実的か
- [ ] スケーラビリティは考慮されているか
- [ ] ユーザーの技術レベルに合っているか

---

## Step 3: フェーズ分割（Phase 1〜N）

### 分割の原則

#### 原則1: 依存関係順に分割

```
Phase 1: 環境構築
  ↓（Phase 1 完了後に Phase 2 が可能）
Phase 2: データ取得
  ↓（Phase 2 完了後に Phase 3 が可能）
Phase 3: データ処理
```

#### 原則2: 1フェーズ = 1つの大きな機能単位

**良い例:**
- Phase 1: 環境構築とプロジェクト初期化
- Phase 2: RSS フィード取得とパース機能
- Phase 3: LLM 連携と要約生成

**悪い例:**
- Phase 1: 環境構築、RSS取得、要約、UI実装（詰め込みすぎ）

#### 原則3: 各フェーズは独立して動作確認可能

各フェーズ終了時点で、**何か動くものが存在**すること。

**例:**
- Phase 2 終了時: RSS から記事タイトルが取得できる
- Phase 3 終了時: コンソールに要約が出力される

### フェーズ分割テンプレート

```markdown
## Phase X: [フェーズ名]

**目標**: [このフェーズで達成すること]

**成果物**:
- ファイル1
- ファイル2

**動作確認観点**:
- [ ] 確認項目1
- [ ] 確認項目2

**想定所要時間**: X日
```

---

## Step 4: ステップ分割（Step X-Y）

### 分割の原則

#### 原則1: 1ステップ = 30分〜2時間で完了

ステップが大きすぎると、動作確認が遅れてエラー箇所が特定しにくくなる。

**目安:**
- 初心者向け: 30分〜1時間
- 中級者向け: 1〜2時間
- 上級者向け: 2〜3時間

#### 原則2: 各ステップは独立して動作確認可能

```
Step 2-1: RSS パーサーのインストールと動作確認
  → ここで RSS 取得が動作することを確認

Step 2-2: 本文抽出ロジックの実装
  → ここで本文が抽出できることを確認
```

#### 原則3: ユーザー実装部分とClaude準備部分を明確化

```
Claude が準備:
- テンプレートファイル
- 設定ファイル
- サンプルデータ

ユーザーが実装:
- コアロジック（TODO(human)）
- ビジネスロジック
```

### ステップ命名規則

```
Step [Phase番号]-[ステップ番号]: [動詞] + [目的語]
```

**良い例:**
- Step 1-1: Node.js 環境確認とパッケージマネージャーセットアップ
- Step 2-1: RSS パーサーのインストールと動作確認
- Step 3-1: Gemini API キーの設定と疎通確認

**悪い例:**
- Step 1: セットアップ（抽象的すぎ）
- Step 2: データを取る（曖昧）

---

## Step 5: 各ステップの詳細ドキュメント作成

### ドキュメントテンプレート

各ステップドキュメントは以下の構成に従う:

```markdown
# Step X-Y: [ステップ名]

## 目標
[このステップで達成する具体的なゴール（1文）]

---

## 前提知識

### [概念A] とは
[技術・概念の説明]

### なぜ [概念A] なのか
[選定理由、メリット]

---

## 作業手順

### 1. [作業タイトル]

[コマンドまたは手順]

```bash
# コマンド例
npm install パッケージ名
```

**コマンド解説:**
- `オプション1`: 説明
- `オプション2`: 説明

---

## ユーザー実装部分

### `ファイルパス` の作成

以下のファイルを**あなたが作成**するのだ:

```typescript
// TODO(human): 実装指示
// 1. 処理A
// 2. 処理B
// 3. 処理C
```

**実装のヒント:**

<details>
<summary>ヒント1: [タイトル]</summary>

```typescript
// 部分的なヒント
```
</details>

<details>
<summary>ヒント2: [タイトル]</summary>

```typescript
// より具体的なヒント
```
</details>

<details>
<summary>完全な解答例（どうしても困ったら見る）</summary>

```typescript
// 完全なコード
```
</details>

---

## 動作確認

### 1. [確認方法のタイトル]

```bash
# 実行コマンド
```

### 2. 確認観点

#### ✅ チェックリスト

- [ ] 確認項目1
- [ ] 確認項目2
- [ ] エラーが出ない

#### 期待される出力例

```
[具体的な出力例]
```

---

## トラブルシューティング

### エラー: `エラーメッセージ`

**原因:** [エラーの原因]

**解決:**
```bash
# 解決コマンド
```

---

## [追加の技術解説セクション]

[必要に応じて追加]

---

## 次のステップ

[このステップ]が成功したら、次は [Step X-Y: タイトル](ファイル名.md) に進むのだ！

---

## 学習メモ欄

このステップで学んだこと、気づいたことをメモするのだ:

```
（自由記述）
```
```

### セクションの役割

| セクション | 目的 | 必須 |
|-----------|------|-----|
| 目標 | ステップのゴールを明確化 | ✅ |
| 前提知識 | 技術概念の理解 | ✅ |
| 作業手順 | コマンド実行など機械的作業 | ✅ |
| ユーザー実装部分 | 学習のためのコーディング | ✅ |
| ヒント | 段階的な支援 | ✅ |
| 動作確認 | 成功の判定基準 | ✅ |
| トラブルシューティング | よくあるエラー対処 | ✅ |
| 技術解説 | 深い理解のための補足 | オプション |
| 次のステップ | 進捗管理 | ✅ |
| 学習メモ欄 | 振り返り | ✅ |

---

## ユーザー実装部分の設計指針

### 何をユーザーに実装させるか

#### ✅ ユーザーが実装すべきもの

1. **ビジネスロジック**: RSS解析、要約生成など
2. **データ変換**: 配列操作、オブジェクト整形など
3. **条件分岐**: if/switch による判定ロジック
4. **アルゴリズム**: ソート、フィルタリング、重複排除など

#### ❌ Claude が準備すべきもの

1. **定型的な設定ファイル**: `package.json`, `tsconfig.json` など
2. **テンプレートコード**: コンポーネントの骨組み
3. **型定義**: TypeScript の interface/type
4. **ディレクトリ構造**: フォルダ作成

### TODO(human) の書き方

#### 良い例

```typescript
// TODO(human): 以下の処理を実装してください
// 1. feeds.json から RSS フィード一覧を読み込む
// 2. 各フィードから最新 10 件の記事を取得
// 3. 各記事の本文を抽出して Gemini で要約
// 4. 重複を排除（URL ハッシュで判定）
// 5. 日時降順でソート
// 6. data/news.json に出力
```

**特徴:**
- 具体的な手順を番号付きリストで提示
- 各手順が測定可能（実装したか判定できる）

#### 悪い例

```typescript
// TODO(human): RSS を処理してください
```

**問題点:**
- 抽象的すぎて何をすればいいか分からない
- 手順が明確でない

### ヒントの段階設計

#### 3段階ヒント方式

```
ヒント1: 概念レベル（「〇〇を使う」）
  ↓
ヒント2: 構造レベル（「こういう構造で書く」）
  ↓
ヒント3: コードレベル（「この関数を使う」）
  ↓
完全解答: 動作するコード
```

#### 具体例

**ヒント1（概念）:**
```
Parser のインスタンスを作成し、parseURL() で取得する
```

**ヒント2（構造）:**
```typescript
const parser = new Parser();
const feed = await parser.parseURL(url);
for (const item of feed.items) {
  // ここで処理
}
```

**ヒント3（コード）:**
```typescript
const parser = new Parser();
const feed = await parser.parseURL(firstFeed.url);

for (let i = 0; i < 3 && i < feed.items.length; i++) {
  console.log(`記事${i + 1}: ${feed.items[i].title}`);
}
```

**完全解答:**
```typescript
import Parser from 'rss-parser';
import * as fs from 'fs/promises';

async function testRssFeed() {
  try {
    const parser = new Parser();
    const feedsJson = await fs.readFile('feeds.json', 'utf-8');
    const feedsData = JSON.parse(feedsJson);
    const firstFeed = feedsData.feeds[0];

    console.log(`フィード名: ${firstFeed.name}\n`);

    const feed = await parser.parseURL(firstFeed.url);

    for (let i = 0; i < 3 && i < feed.items.length; i++) {
      console.log(`記事${i + 1}: ${feed.items[i].title}`);
    }
  } catch (error) {
    console.error('エラー:', error);
  }
}

testRssFeed();
```

---

## 動作確認観点の設計

### チェックリスト形式

```markdown
#### ✅ チェックリスト

- [ ] 具体的な確認項目1（例: タイトルが3件表示される）
- [ ] 具体的な確認項目2（例: エラーが出ない）
- [ ] 具体的な確認項目3（例: 処理が5秒以内に完了）
```

### 期待される出力例

```markdown
#### 期待される出力例

\`\`\`
フィード名: Zenn
URL: https://zenn.dev/feed

=== 最新記事（3件）===
記事1: Expo Router で型安全なルーティングを実現する
記事2: React 19 の新機能まとめ
記事3: TypeScript 5.5 で追加された機能
\`\`\`
```

**ポイント:**
- 実際のコンソール出力をそのまま記載
- コピペして比較できる形式

---

## トラブルシューティングの設計

### 想定すべきエラー

各ステップで以下のエラーを想定する:

1. **環境エラー**: パッケージ未インストール、バージョン不一致
2. **ネットワークエラー**: API タイムアウト、接続失敗
3. **設定エラー**: 環境変数未設定、設定ファイル不備
4. **ロジックエラー**: シンタックスエラー、型エラー

### テンプレート

```markdown
### エラー: `具体的なエラーメッセージ`

**原因:** [エラーが発生する理由]

**解決:**
```bash
# 具体的な解決コマンド
```

**デバッグ方法:**
```typescript
// デバッグ用のコード
console.log('変数名:', 変数);
```
```

---

## 全体計画ドキュメント（implementation-plan.md）の構成

```markdown
# [プロジェクト名] 段階的実装計画

## 前提
- アーキテクチャ: [概要]
- 学習方針: [方針]
- 開発スタイル: [スタイル]

---

## Phase 1: [フェーズ名]

### Step 1-1: [ステップ名]
**目標**: [ゴール]

**作業内容**:
1. [作業1]
2. [作業2]

**動作確認観点**:
```bash
# 確認コマンド
```

**期待結果**: [結果]

---

[Phase 2以降も同様]

---

## 成功基準
- ✅ 基準1
- ✅ 基準2

## コスト見積もり
- サービスA: $X/月
- 合計: $Z/月

**合計期間: X週間**
```

---

## READMEドキュメント（implementation-steps/README.md）の構成

```markdown
# Implementation Steps - 実装ステップガイド

## 📚 ステップ一覧

### Phase 1: [フェーズ名]
- [Step 1-1: タイトル](step-1-1-filename.md)
- [Step 1-2: タイトル](step-1-2-filename.md)

---

## 🎯 使い方

### 1. 順番に進める
### 2. 動作確認を必ず行う
### 3. 学習メモを活用

---

## 📖 記法について

### TODO(human)
### ヒントと解答例

---

## 🔧 よく使うコマンド

---

## 🆘 困ったときは

---

## 📈 進捗管理

[チェックリスト]

---

## 💡 学習のポイント
```

---

## ファイル命名規則

### ディレクトリ構造

```
docs/
├── implementation-plan.md           # 全体計画
├── planning-methodology.md          # この標準化ルール
└── implementation-steps/
    ├── README.md                    # ステップ一覧とガイド
    ├── step-1-1-environment-setup.md
    ├── step-1-2-create-expo-project.md
    ├── step-2-1-rss-parser-setup.md
    └── ...
```

### ファイル名規則

```
step-[Phase番号]-[ステップ番号]-[kebab-case-title].md
```

**例:**
- `step-1-1-environment-setup.md`
- `step-2-1-rss-parser-setup.md`
- `step-3-2-article-summarization.md`

---

## 実装の進め方（実装者向け）

### 1. 全体計画の確認

[docs/implementation-plan.md](implementation-plan.md) を読み、全体像を把握

### 2. README の確認

[docs/implementation-steps/README.md](implementation-steps/README.md) で使い方を理解

### 3. ステップ実行

```
Step 1-1 を開く
  ↓
前提知識を読む
  ↓
作業手順を実行
  ↓
ユーザー実装部分を実装
  ↓（詰まったらヒントを見る）
動作確認
  ↓
チェックリストを確認
  ↓
学習メモを記入
  ↓
次のステップへ
```

---

## Claude への依頼方法（計画作成時）

### 依頼テンプレート

```
以下の要件で実装計画を立ててください。

【コア要件】
- 要件1
- 要件2
- 要件3

【制約条件】
- コスト: 月額 $X 以下
- 技術スタック: [指定があれば]
- 期間: X週間以内

【学習方針】
- ステップごとに動作確認可能にする
- ユーザーがコアロジックを実装する
- 小さい単位で分割する

【出力形式】
1. docs/implementation-plan.md（全体計画）
2. docs/implementation-steps/README.md（ステップ一覧）
3. docs/implementation-steps/step-X-Y-*.md（各ステップ詳細）
```

### Claude の作業フロー

```
1. 要件整理
   ↓
2. アーキテクチャ設計（技術スタック決定）
   ↓
3. フェーズ分割（Phase 1〜N）
   ↓
4. 各フェーズをステップ分割（Step X-Y）
   ↓
5. implementation-plan.md 作成
   ↓
6. 各ステップの詳細ドキュメント作成
   ↓
7. README.md 作成
```

---

## チェックリスト（計画作成者向け）

### 全体計画

- [ ] アーキテクチャ図がある
- [ ] 技術選定の理由が明記されている
- [ ] コスト試算がある
- [ ] 成功基準が明確
- [ ] 想定期間が記載されている

### フェーズ分割

- [ ] 各フェーズが独立して動作確認可能
- [ ] フェーズ間の依存関係が明確
- [ ] 1フェーズ = 1〜3日程度の作業量
- [ ] 各フェーズに成果物と動作確認観点がある

### ステップ分割

- [ ] 各ステップが独立して動作確認可能
- [ ] 1ステップ = 30分〜2時間程度
- [ ] ステップ名が「動詞 + 目的語」形式
- [ ] ユーザー実装部分とClaude準備部分が明確

### 各ステップドキュメント

- [ ] 目標が1文で明確
- [ ] 前提知識セクションがある
- [ ] TODO(human) が具体的
- [ ] 3段階ヒントがある
- [ ] 完全解答がある
- [ ] 動作確認のチェックリストがある
- [ ] 期待される出力例がある
- [ ] トラブルシューティングが3つ以上
- [ ] 次のステップへのリンクがある
- [ ] 学習メモ欄がある

---

## この標準化ルールの適用例

このドキュメント自体が作成した [Recaplet プロジェクト](../implementation-plan.md) がリファレンス実装なのだ。

---

## まとめ

### この手法の利点

1. ✅ **学習効果が高い**: ユーザーが自分でコードを書く
2. ✅ **エラーに強い**: 小さい単位でテストするため早期発見
3. ✅ **再現性が高い**: 標準化されているため他プロジェクトにも適用可能
4. ✅ **進捗管理しやすい**: チェックリストで進捗が可視化

### 適用すべきプロジェクト

- 学習目的のプロジェクト
- 初心者が関わるプロジェクト
- 複雑な技術スタックを使うプロジェクト
- 長期間かかるプロジェクト

### 適用すべきでないケース

- 1時間で終わる簡単なタスク
- 定型作業の繰り返し
- プロトタイプ作成（速度重視）

---

このルールに従って計画を立てれば、誰でも学習しながら確実に実装を進められるのだ！🚀
